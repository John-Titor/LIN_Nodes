#!/usr/bin/tclsh
# 
# ----------------------------------------------------------------------------
# "THE BEER-WARE LICENSE" (Revision 42):
# <msmith@purgatory.org> wrote this file. As long as you retain this notice you
# can do whatever you want with this stuff. If we meet some day, and you think
# this stuff is worth it, you can buy me a beer in return.
# ----------------------------------------------------------------------------
# 
#
# Generator for magic numbers, class definitions and the like. This is not
# a real LDF parser, but it serves a similar purpose.
#
# Parses a DSL from the input file and generates code to suit. Note that the
# input is Tcl, so normal language constructs are available to simplify
# code generation.
#
# DSL grammar:
#
# REVISION <revision-number>
#   Sets the protocol revision number
#
# ENUM <enum-name> { <element-name> [<element-name>...]}
#   Generates an enumeration and a table of strings matching the
#   individual element names. The first element is always zero.
#   Each element is named k<enum-name><element-name>, and an 
#   element named k<enum-name>Max is appended to the end of the
#   enumeration.
#
# parameters <node-name>
#   Declares the existence of a node <node-name>, for which parameters
#   can be defined.
#
# <node-name> <parameter-name> "display-name" "format-string" <minimum-value> <maximum-value> <default-value>
#   Defines a parameter for previously-delcared node.
#

package require fileutil
package require cmdline

set linenumber -1
set revision -1
set enums [dict create]
set parameters [dict create]

namespace eval ::cmds {

    variable current_enum "none"
    variable parameter_node "none"

    proc revision {val} {
        global revision

        if {$revision != -1} {
            error "duplicate revision keyword"
        }
        set revision $val
    }

    proc enum {enum_name elements} {
        global enums

        if {[dict exists $enums $enum_name]} {
            error "duplicate enum name '${enum_name}'"
        }
        dict set enums $enum_name $elements
    }

    proc parameters {node_name} {
        global parameters
        global parser

        if {[dict exists $parameters $node_name]} {
            error "duplicate node name '${node_name}'"
        }
        dict set parameters $node_name [dict create]
        $parser alias $node_name ::cmds::parameter_append $node_name
    }

    proc parameter_append {node_name parameter_name display_name display_format minimum_value maximum_value defalt_value} {
        global parameters

        if {[dict exists $parameters $node_name $parameter_name]} {
            error "duplicate parameter name '${parameter_name}' for '${node_name}'"
        }
        dict set parameters $node_name $parameter_name [dict create \
            display_name $display_name                              \
            display_format $display_format                          \
            min $minimum_value                                      \
            max $maximum_value                                      \
            default $defalt_value                                   \
        ]
    }
}

# make sure we can read the input file
set spec [lindex $argv 0]
if {![file readable $spec]} {
    error "${spec} unreadable"
}
set input [::fileutil::cat -- $spec]

# construct the interpreter we're going to use to process the spec
set parser [interp create -safe]

# add our basic verbs
$parser alias REVISION ::cmds::revision
$parser alias ENUM ::cmds::enum
$parser alias PARAMETERS ::cmds::parameters

# process the file and toss the interpreter
$parser eval $input
interp delete $parser

# Generate the protocol header
set fh [open "protocol.h" "w"]
puts $fh "// AUTOMATICALLY GENERATED, DO NOT EDIT"
puts $fh "#pragma once"
puts $fh "#ifdef __AVR__"
puts $fh "# include <avr/pgmspace.h>"
puts $fh "#else"
puts $fh "# define PROGMEM"
puts $fh "#endif"
puts $fh "#include <stdint.h>"
puts $fh ""
puts $fh "static const uint8_t protocolRevision = $revision;"
puts $fh ""

# emit enum defintions
dict for {enum_name enum_data} $enums {
    puts $fh "enum $enum_name : uint8_t {"
    foreach element_name $enum_data {
        puts $fh "    k${enum_name}${element_name},"
    }
    puts $fh "    k${enum_name}Max"
    puts $fh "};"
    puts $fh ""
    puts $fh "static PROGMEM const char namesFor${enum_name}\[\] = "
    foreach element_name $enum_data {
        puts $fh "    \"$element_name\\0\""
    }
    puts $fh "    \"\\0\";"
    puts $fh ""
}
puts $fh ""
close $fh

# Generate parameter files
dict for {node node_params} $parameters {
    set fh [open "../nodes/lib/param_$node.h" "w"]
    puts $fh "// AUTOMATICALLY GENERATED, DO NOT EDIT"
    puts $fh "#pragma once"
    puts $fh "#include <stdint.h>"
    puts $fh "#include <parameter.h>"
    puts $fh ""
    puts $fh "extern const uint8_t ${node}ParamInfo\[\];"
    puts $fh "extern const char ${node}ParamNames\[\];"
    puts $fh "extern const char ${node}ParamFormats\[\];"
    puts $fh ""
    set index 0
    dict for {param_name param_info} $node_params {
        incr index
        puts $fh "#define kParam${param_name} ${index}"
    }
    puts $fh "#define k[string totitle ${node}]ParamMax ${index}"
    puts $fh "#define ${node}Param(_index) Parameter((_index), &${node}ParamInfo\[(_index) * 3\])"
    puts $fh ""
    dict for {param_name param_info} $node_params {
        puts $fh "#define param${param_name} ${node}Param(kParam${param_name})"
    }
    puts $fh ""
    puts $fh "#define ${node}ParamAll(method, ...) \\"
    dict for {param_name param_info} $node_params {
        puts $fh "    param${param_name}.method(__VA_ARGS__); \\"
    }
    puts $fh "struct hack"
    close $fh

    set fh [open "../nodes/lib/param_$node.cpp" "w"]
    puts $fh "// AUTOMATICALLY GENERATED, DO NOT EDIT"
    puts $fh "#include <parameter.h>"
    puts $fh "#include <lin_protocol.h>"
    puts $fh "#include <protocol.h>"
    puts $fh "#include \"param_${node}.h\""
    puts $fh ""
    puts $fh "PROGMEM const char ${node}ParamNames\[\] = "
    puts $fh "    \" \\0\""
    dict for {param_name param_info} $node_params {
        set name [dict get $param_info display_name]
        puts $fh "    \"${name}\\0\""
    }    
    puts $fh "    \"\\0\";"
    puts $fh ""
    puts $fh "PROGMEM const char ${node}ParamFormats\[\] = "
    puts $fh "    \" \\0\""
    dict for {param_name param_info} $node_params {
        set format [dict get $param_info display_format]
        puts $fh "    \"${format}\\0\""
    }    
    puts $fh "    \"\\0\";"
    puts $fh ""
    puts $fh "PROGMEM const uint8_t ${node}ParamInfo\[\] = {"
    puts $fh "    0, 0, 0,"
    dict for {param_name param_info} $node_params {
        set min [dict get $param_info min]
        set max [dict get $param_info max]
        set default [dict get $param_info default]
        puts $fh "    ${min}, ${max}, ${default},"
    }
    puts $fh "};"
    close $fh
}
